# C++八股汇总
1. `malloc`的底层实现原理？
答： `malloc` 的底层实现通常通过管理一个空闲内存块的链表来进行。当程序请求内存时，`malloc` 会遍历这个链表，找到第一个足够大的空闲块，并分配内存。如果空闲块比请求的内存大，可能会将其拆分。为了避免内存碎片化，free 释放内存时会合并相邻的空闲块。内存对齐通常是为了提高访问效率，`malloc` 会保证返回的内存块按照一定的对齐方式分配。不同的实现可能使用 `sbrk` 或 `mmap` 来向操作系统请求内存，且现代实现常用锁机制来保证线程安全。

2. `atomic`和 `mutex`的实现原理？

答：`atomic` 操作通常依赖于硬件提供的原子指令（如 x86 中的 LOCK 前缀或 ARM 中的 LDREX 和 STREX），这些指令保证了操作的不可中断性，从而避免了线程间的竞态条件。常见的原子操作包括原子加法、比较并交换（CAS）等，它们在硬件层面确保了操作的原子性和一致性。相比之下，`mutex`（互斥锁）通过操作系统提供的系统调用或线程库实现，通常使用原子操作（如 compare-and-swap）来管理锁的获取与释放。互斥锁通过引入阻塞机制（比如自旋锁、阻塞等待等）来确保同一时刻只有一个线程可以访问临界区。

3. CAS指令与ABA问题？

答：

- `CAS`（Compare-And-Swap）指令 是一种原子操作，用于比较内存中的某个值与预期值是否相等，如果相等，则将该值更新为新值。CAS 指令通常用于实现无锁的同步机制，广泛用于实现原子操作和并发数据结构。CAS 的原理是比较、更新和返回旧值的过程，只有在预期值和当前值相等时才执行更新操作。

- `ABA` 问题 是 CAS 操作中可能遇到的一个问题，指的是一个值从 A 变为 B 后又变回 A，导致 CAS 判断为相等，从而执行更新，但实际上这个值已经发生过变化，可能会导致逻辑错误。ABA 问题的根源在于 CAS 无法区分值的“历史变化”。

解决 ABA 问题的方法：

- 引入版本号：一种常见的解决方案是为每个值引入一个版本号（或时间戳）。每次更新时，不仅更新值，还更新版本号。CAS 比较时会同时检查版本号，这样即使值变回了原来的状态，也能通过版本号的变化来避免错误。

- 使用指针版本（如标记位）：在一些实现中，通过增加一个指针标记位来避免 ABA 问题。每次修改值时，都会改变指针或标记，这样即使值本身发生了变化，CAS 操作也能正确识别。

