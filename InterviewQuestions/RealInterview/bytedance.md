# 计算机基础
1. auto 和 decltype的区别？
答：
   - auto：根据初始化表达式推导变量类型，**运行时**根据右值推导；
   - decltype：根据表达式推导类型，但不计算值，**编译时**根据表达式类型推导。
2. 三种智能指针的应用场景
答：
    - `unique_ptr`：只允许基础指针的一个所有者。
    - `shared_ptr`：采用引用计数的智能指针。
    - `weak_ptr`：结合shared_ptr使用的特例智能指针。weak_ptr提供对一个或多个shared_ptr实例拥有的对象的访问，但不参与引用计数。

3. 右值和`move`的用法
答：
    - 右值引用：C++11 引入了右值引用，通过 T&& 绑定右值，主要用于移动语义，避免不必要的拷贝，提高效率。
    - `move`函数：
      - 提高性能：避免深拷贝，直接转移资源。
      - 减少内存分配：原有资源被转移，减少临时对象创建。
      - 提升灵活性：适用于大型容器、动态内存对象。
4. 操作系统进程和线程的区别

|特性|进程|线程|
|--|--|--|
|基本单位|资源分配的基本单位|调度和执行的基本单位|
|资源共享|不共享，各进程有独立的地址空间|共享|
|创建开销|大，需要独立分配资源|小，只需要创建寄存器和栈帧|
|切换速度|慢，涉及上下文切换和地址映射|快，只需要CPU切换上下文|
|通信方式|通过IPC（管道，共享内存，消息队列）|通过共享内存|
|多核利用|多进程并行|多线程并发|
|适用场景|独立任务|并发任务|

5. 进程间通信方式

|通信方式|特点|适用场景|
|--|--|--|
|管道|单向、半双工、速度快|父子进程简单的数据传输|
|命令管道|双向，不同进程间，支持网络|无亲缘关系的进程间通信|
|消息队列|基于消息格式，支持多对多|多个无关联进程数据交换|
|共享内存|速度最快，需要同步机制|大量数据高速共享|
|套接字|支持本地和网络间进程间通信|网络通信、分布式系统|
|信号|轻量级，处理异步事件通知|通知进程执行特定操作|
|mmap|内存映射文件，共享文件内容|文件内容共享，进程间读写|

6. 死锁的必要条件
1）**互斥条件**：资源一次只能被一个进程占用，如果其他进程需要使用该资源，必须等待其释放。
2）**请求与保持条件**：进程在等待其他资源时，不会释放已占有的资源，而是继续保持它们。
3）**不可剥夺条件**：资源不能被强制抢占，只能由占有资源的进程主动释放。
4）**循环等待条件**：存在一组进程 {P1, P2, ..., Pn}，其中每个进程都在等待下一个进程所持有的资源，形成一个环形等待链。

7. C++ 类的初始化方法有哪些？
1）默认初始化；
2）值初始化；
3）列表初始化：使用大括号 {}对对象进行初始化，C++11 引入，支持聚合类和构造函数。；
4）拷贝初始化；
5）移动初始化；
6）显式初始化；
7）委托构造：一个构造函数委托另一个构造函数；

8. 数据库锁的类型
数据库锁的类型：
答：
1）共享锁（S锁）：允许多个事务**同时读取**数据，但不能进行修改。
2）排他锁（X锁）：只允许**一个事务**访问数据，其他事务不能读也不能写。
3）意向锁：表级别的**辅助锁**，用于标识事务对某一行是否加了行锁。
4）悲观锁：每次数据访问时，都**假设有并发冲突**，因此主动加锁，直到事务完成。
5）乐观锁：**假设数据冲突概率低**，不加锁，在更新时检测数据是否被修改。
# 场景问题

1. 在弱网环境下，网络协议该如何设计？
答：
网络层优化：
    - 多路径TCP（MPTCP），利用多个网络接口（如 4G+5G+Wi-Fi）并行传输，自动切换与负载均衡。
    - IP快速切换：使用 Mobile IP、MP-TCP，在网络切换时保持 IP 地址不变，避免中断。
    - 智能路由选择：动态监测路径质量，优先选择延迟低、丢包少的路径传输。
    - QUIC协议：基于 UDP，支持 0-RTT 建立连接，适合高延迟和切换场景。
传输层优化：
   - BBR 拥塞控制：基于带宽估计动态调整窗口，适应弱网环境，避免超时重传。
   - TCP Fast Open (TFO)：减少 TCP 握手时间，提升短连接速度。
   - TCP Pacing：均匀发送数据，防止突发导致丢包。
   - Selective ACK (SACK)：支持选择性确认，避免整窗口重传，提升弱网性能。
   - 动态 RTO：根据网络质量动态调整重传超时时间，避免早重传或迟重传。

2. TCP重传机制？
答：
- 确认（ACK）机制：
    - TCP通过确认（ACK）机制确保数据包的接收情况。每当接收方收到一个数据段时，它会发送一个确认报文段（ACK）告知发送方数据已成功接收。确认报文段包含了下一个期望接收的字节序列号。
    - 如果发送方在一定时间内没有收到目标端的确认，它就会认为数据丢失或发生了错误，然后进行重传。
- 重传超时（RTO）：
    - TCP会设置一个重传超时时间（RTO），即如果发送的数据包在这个时间内没有收到确认，发送方就会重新发送数据。
    - RTO的值并不是固定的，它会动态调整，通常基于往返时间（RTT）和RTT的偏差计算得到。具体通过以下公式计算：RTO = SRTT + 4 * RTTVAR其中，SRTT是平滑的RTT估算值，RTTVAR是RTT的变化幅度。
- 快速重传（Fast Retransmit）：
    - 如果发送方收到三个重复的ACK报文段（即接收方确认收到了按序号递增的数据段，但某个中间数据段丢失），TCP会认为数据丢失并立即重传丢失的数据段。这种机制称为快速重传。
    - 快速重传能够比重传超时机制更快地进行数据重传，减少延迟。

3. 网络协议栈是如何通过驱动将数据报文交付给网卡的？
答：

- 数据进入发送队列（**TX Ring Buffer**），存储在内存缓冲区中。
- **DMA机制**让网卡直接访问内存，读取数据，提高效率。
- 驱动写入**网卡寄存器**，通知网卡发送。
- 网卡通过**PHY模块**发送数据到网络。
- 网卡发送完成后，通过中断通知驱动，释放资源。


4. 一个socket的send函数发送数据报是如何实现的？
答：

- 应用层：应用程序调用**Socket**接口传输数据。
- 传输层：**TCP/UDP协议**封装数据，形成报文段。
- 网络层：IP协议封装，路由查找并添加IP头。
- 数据链路层：**ARP查询**MAC地址，封装以太网帧。
- 物理层：网卡驱动将数据发送到网卡，转化为信号传输。


5. eBPF的挂载点有哪些？
答：

| **类别** | **挂载点** | **作用** |
|---------|-----------|---------|
| **网络** | XDP | 处理 L2 层数据包，低延迟 |
|  | TC | 处理 L3/L4 层数据，流量控制 |
|  | Socket | 过滤应用层流量 |
| **系统调用** | seccomp | 沙箱安全 |
|  | kprobes/uprobes | 跟踪内核/用户函数 |
| **内核跟踪** | Tracepoints | 监控内核事件 |
|  | Perf Events | CPU 监控 |
| **Cgroup** | cgroup/bpf | 进程隔离，资源管理 |
| **安全** | LSM | 访问控制 |

