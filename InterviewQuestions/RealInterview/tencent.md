1. new 和 malloc 的区别？

|特性| new/delete | malloc/free |
|--|--|--|
|**语言支持**|C++| C/C++|
|**返回类型**|类型指针，自动转换|void*，需要手动转换|
|**初始化**|自动调用构造函数并初始化|不调用构造函数，需手动初始化|
|**释放内存**|`delete` / `delete[]`|`free()`|
|**异常处理**|内存不足抛出 `std::bad_alloc`|返回 `nullptr`，需手动检查|
2. free 可以对对象使用吗？
答：**不可以**，不会调用析构函数，如果你用 new 创建了一个类对象，free() 只会回收内存，但不会调用对象的**析构函数**，可能会导致资源泄露（如文件、网络、内存未释放）。此外，内存管理方式不一致new 依赖于 C++ 的内存管理系统，通过 operator new 分配内存。malloc/free 属于 C 标准库，依赖于 C 的堆分配方式。这两种方式的实现可能使用了不同的堆分配机制，混用可能导致 未定义行为（UB, Undefined Behavior）。


3. malloc和new分配的地址是虚拟地址还是物理地址，它们是怎么做转换的？
答：在现代操作系统（如 Linux、Windows、macOS）中，`malloc` 和 `new` 分配的地址是虚拟地址，而非物理地址。程序运行时，访问的都是虚拟地址，操作系统和硬件（MMU，内存管理单元）负责将虚拟地址映射到实际的物理地址。CPU 取指令或数据时，访问虚拟地址。MMU 通过页表找到虚拟地址对应的物理地址。若找到映射，直接访问物理内存（TLB 命中）。若未找到映射，触发 缺页异常，OS 分配新页并更新页表。

4. 进程和线程分别共享哪些资源？
答：
- 全局变量和静态变量；
- 堆内存
- 文件描述符
- 进程资源
  - 地址空间
  - 代码段
  - 静态资源

5. 堆区栈区访问速度对比？

答： 

|特性|栈区(Stack)|堆区(Heap)|
|--|--|--|
|**内存分配方式**|**顺序分配**，栈指针移动，O(1)|**动态分配**，复杂算法，O(log n)|
|**访问速度**|快|慢|
|**管理方式**|**自动**管理，函数退出自动释放|**手动**管理，需 malloc/free|
|**CPU寄存器**|直接基于栈指针，访问开销低|依赖指针，需多级间接寻址|
|**碎片化**|无|有|
|**缓存利用**|	好，数据连续性强|差，随机分布，缓存利用率低|
|**使用场景**|局部变量、函数调用栈|动态分配、生命周期不定的对象|

