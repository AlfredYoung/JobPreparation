# 操作系统

## 操作系统基本概念

1. 进程的状态及其转换

|状态|说明|
|--|--|
|**创建**|进程被创建，但未开始执行|
|**就绪**|进程准备好，等待CPU调度调度执行|
|**运行**|进程获得CPU时间片，正在执行指令|
|**阻塞**|进程等待某个事件（如I/O，信号）完成|
|**终止**|进程执行完毕或被强制结束，进入终止状态。|

启动进程： 
    - 命令行直接启动；
    - 使用`fork()`和`exec()`系统调用；
停止进程：
    - `kill` \<PID>
    - `pkill` Name
    - `systemctl` stop
    - `killall`
挂起进程：
    - `kill` -STOP <PID>  
    - `bg` %1  恢复并在后台执行
    - `fg` %1  将后台进程切换到前台
    - `jobs` 查看后台进程

2. 线程的同步和互斥

在多线程程序中，线程**同步**和线程**互斥**是确保数据一致性和操作正确性的关键。
多线程并发可能会导致**竞态条件**（Race Condition），因此需要使用适当的同步和互斥机制来避免数据竞争。
- 线程同步：确保多个线程按预期的**执行顺序**完成任务，避免操作交错。
- 线程互斥：保证**同一时刻**只有一个线程可以**访问共享资源**，防止数据竞争。

线程实现同步互斥的方法
  - **互斥锁**（Mutex）：保证临界区同一时刻只有一个线程访问。
  - **读写锁**（RWLock）：支持多个读者并发，写操作互斥。
  - **信号量**（Semaphore）：计数器控制资源访问数量。
  - **条件变量**（Condition Variable）：实现线程等待和通知。

3. 内存分区

**栈区**（Stack）：函数调用、局部变量，自动管理，生命周期短。
**堆区**（Heap）：动态内存分配，手动 malloc/free。
**数据区**（Data）：全局变量、静态变量，程序生命周期。
**代码区**（Text）：存放程序指令，只读，防止篡改。

4. 虚拟内存和物理内存

**定义**：提供比实际物理内存更大的地址空间，通过磁盘与内存映射。
**实现方式**：
- 请求分页（按需加载，减少内存消耗）。
- 页面置换算法（LRU、FIFO、Clock）。
**缺页中断**：当访问的页面不在内存时触发，系统调入新页面。



5. 文件系统

文件（File）：
    - **定义**：文件是存储在磁盘上的数据集合，是文件系统管理的基本单位。
    - **文件类型**：
      - 普通文件
      - 目录文件
      - 设备文件
      - 链接文件
文件系统（File System）：
    - **定义**：文件系统是用于存储、组织、管理和访问文件的软件层，负责数据的持久化和检索。
    - **功能：**
      - 文件命名与组织
      - 空间管理（分配和回收）
      - 文件访问与权限控制
      - 数据一致性与崩溃恢复

6. 系统调用

| **类别**            | **常见系统调用**                          | **功能**                                   |
|---------------------|-------------------------------------------|--------------------------------------------|
| **进程管理**        | `fork()`、`exec()`、`wait()`、`exit()`     | 创建、执行、终止、等待子进程               |
| **文件管理**        | `open()`、`read()`、`write()`、`close()`   | 打开、读取、写入、关闭文件                 |
| **内存管理**        | `mmap()`、`brk()`、`sbrk()`                | 内存映射、堆区管理                         |
| **设备管理**        | `ioctl()`、`read()`、`write()`              | 操作设备、输入输出                         |
| **网络通信**        | `socket()`、`bind()`、`listen()`、`accept()` | 创建和管理网络连接                         |
| **时间管理**        | `time()`、`gettimeofday()`、`nanosleep()`   | 获取系统时间、延迟                         |
| **用户管理**        | `getuid()`、`setuid()`                      | 获取、设置用户 ID                          |
| **信息管理**        | `uname()`、`sysinfo()`                      | 获取系统信息                               |
| **信号管理**        | `signal()`、`kill()`、`sigaction()`         | 发送、处理信号                             |
| **线程管理**        | `clone()`、`pthread_create()`               | 创建线程、多线程控制                       |
| **同步与互斥**      | `semop()`、`shmget()`、`futex()`             | 信号量、共享内存、锁操作                   |

7. 进程调度算法

- **先来先服务**（FCFS）：按到达顺序调度，简单但可能导致平均等待时间长。
- **短作业优先**（SJF）：优先调度运行时间最短的进程，平均等待时间最短，但可能导致长作业饥饿。
- **时间片轮转**（RR）：每个进程分配固定时间片，适合分时系统。
- **优先级调度**：根据进程优先级调度，可能需要配合老化机制防止低优先级进程饥饿。
- **多级反馈队列**：结合时间片轮转和优先级，综合考虑响应速度与吞吐量。

8. 页面置换算法

- FIFO：淘汰最早进入内存的页面，简单但可能出现 Belady 异常。
- LRU：淘汰最近最少使用的页面，性能好但开销大。
- LFU：淘汰使用次数最少的页面，可能不适应局部性变化。
- OPT：理论最优算法，淘汰未来最长时间不会访问的页面，只能用于理论分析。

9.  中断与异常

- 中断：由外部设备触发（如 I/O 完成、时钟中断），打断 CPU 正常执行，转入内核处理。

- 异常：由程序执行引起（如缺页异常、除零错误、系统调用），通常需要操作系统介入处理。
中断和异常机制保证了操作系统的可控性和对硬件、程序的管理能力。

10. 缓存机制

CPU Cache：分为 L1、L2、L3，用于减少访问内存的延迟。

页缓存（Page Cache）：操作系统在内存中缓存文件内容，加速文件 I/O。

缓冲区缓存（Buffer Cache）：缓存磁盘块数据，加快读写速度。
缓存机制的核心思想是利用局部性原理（时间局部性和空间局部性），在命中时大幅提升性能，但需要考虑一致性问题。

## Linux用法

1. Linux常用命令

1. `ls`, `cd`, `pwd`, `mkdir`, `rmdir`, `rm` 等文件操作命令。
2. `cat`, `more`, `less`, `head`, `tail` 等文件查看命令。
3. `cp`, `mv`, `touch` 等文件复制、移动和创建命令。
4. `find`, `locate` 等查找文件的命令。
5. `chmod`, `chown`, `chgrp` 等权限管理命令，使用 chmod 可以修改文件权限，chown 修改文件的所有者，chgrp 修改文件的所属组。
6. `ps`, `top`, `htop`, `kill`, `killall` 等进程管理命令。
7. `df`, `du`, `free`, `uptime` 等系统状态查看命令。

2. Linux进程和线程管理

- Linux 内核用 task_struct 统一管理进程和线程。
- 全部任务通过 双向循环链表 和 PID 哈希表组织。
- 调度由 CFS 调度器负责，基于 红黑树 实现。
- 线程由 clone() 创建，本质是共享部分资源的轻量级进程。

3. Linux网络管理

|命令|功能|
|--|--|
|`ifconfig`|用于显示和配置网络接口信息|
|`ip`|现代 Linux 系统中用于管理网络设备、路由、IP 地址等，功能更强大、灵活，已完全取代 ifconfig|
|`netstat`|用于显示网络连接、路由表、端口使用情况、网络接口统计信息。|
|`ss`|显示套接字（Socket）统计信息，查看TCP/UDP 连接、监听端口、连接状态，功能类似于 netstat，但执行速度更快。|
|`ping`|用于测试网络连通性，通过发送 ICMP 回显请求（Echo Request）来判断目标主机是否可达。|
|`traceroute`|显示数据包从本地主机到目标主机的路由路径，帮助排查网络延迟和节点问题。|
|`curl`|强大的命令行工具，用于执行 HTTP/HTTPS、FTP、SFTP 等多种协议的数据请求，支持文件下载、接口测试、REST API 调试等。|
|`wget`|主要用于从Web下载文件，支持 HTTP、HTTPS、FTP 协议，适用于批量下载、离线抓取。|

4. Linux磁盘管理

| 命令          | 功能描述                                                                 |
|---------------|--------------------------------------------------------------------------|
| df            | 显示文件系统磁盘空间使用情况（已用/可用容量、挂载点）                    |
| du            | 显示目录或文件占用的磁盘空间大小                                         |
| lsblk         | 列出所有块设备（磁盘、分区）及挂载情况                                   |
| fdisk         | 分区工具，用于 MBR 分区表，交互式操作                                    |
| parted        | 分区工具，支持 GPT 分区表，功能更强                                      |
| mkfs          | 在分区上创建文件系统（如 ext4、xfs 等）                                  |
| mount         | 挂载文件系统到指定目录                                                   |
| umount        | 卸载已挂载的文件系统                                                     |
| blkid         | 显示块设备的 UUID 和文件系统类型                                         |
| tune2fs       | 调整 ext 系列文件系统参数（如挂载次数、检查间隔）                        |
| fsck          | 文件系统检查与修复                                                       |
| iostat        | 监控磁盘 I/O 性能（属于 sysstat 包）                                     |
| sar -d        | 查看磁盘 I/O 统计信息（属于 sysstat 包）                                 |
| dd            | 按块复制文件或磁盘，可用于磁盘备份和性能测试                             |
| smartctl      | 查询磁盘的 SMART 信息（健康状态、错误日志等，需要 smartmontools 包）     |
| hdparm        | 查看/设置 SATA 磁盘的参数（缓存、读写速度测试等）                        |


5. Linux性能监控

| 命令        | 功能描述                                                                 |
|-------------|--------------------------------------------------------------------------|
| top         | 动态监控系统整体运行情况（CPU、内存、进程等），实时刷新                   |
| htop        | top 的增强版，交互性更强，支持彩色显示、滚动查看                          |
| vmstat      | 显示内存、CPU、进程、I/O 等系统整体性能指标                               |
| free        | 查看内存和交换分区的使用情况                                             |
| iostat      | 显示 CPU 使用率和磁盘 I/O 统计信息（sysstat 包）                          |
| sar         | 系统运行情况收集工具，可显示 CPU、内存、I/O、网络等历史数据（sysstat 包） |
| mpstat      | 显示每个 CPU 核心的使用情况（sysstat 包）                                |
| pidstat     | 监控某个进程的 CPU、内存、I/O 使用情况（sysstat 包）                      |
| dstat       | 综合监控工具，显示 CPU、磁盘、网络、内存等信息                            |
| perf        | Linux 性能分析工具，支持函数级别的性能分析和热点查找                      |
| strace      | 跟踪进程的系统调用，用于诊断性能瓶颈或错误                                |
| lsof        | 列出系统中打开的文件（包括网络连接、设备等），排查资源占用问题            |
| netstat     | 显示网络连接、路由表、接口状态（已逐渐被 ss 替代）                        |
| ss          | 查看套接字统计信息，替代 netstat，性能更好                                |
| dmesg       | 查看内核日志，常用于检查硬件、驱动和系统错误信息                          |
| uptime      | 显示系统运行时间、平均负载                                               |


6. 权限与用户管理

| 命令          | 功能描述                                                                 |
|---------------|--------------------------------------------------------------------------|
| useradd       | 新建用户                                                                 |
| userdel       | 删除用户                                                                 |
| passwd        | 设置或修改用户密码                                                       |
| su            | 切换用户                                                                 |
| sudo          | 以其他用户（默认 root）身份执行命令                                      |
| id            | 显示当前用户的 UID、GID 和所属组信息                                     |
| whoami        | 显示当前用户的用户名                                                     |
| groups        | 显示用户所属的所有组                                                     |
| groupadd      | 新建用户组                                                               |
| groupdel      | 删除用户组                                                               |
| gpasswd       | 为组添加用户或管理组成员                                                 |
| chmod         | 修改文件或目录权限（读 r=4，写 w=2，执行 x=1）                           |
| chown         | 修改文件或目录的所有者和所属组                                           |
| chgrp         | 修改文件或目录的所属组                                                   |
| umask         | 设置新建文件或目录的默认权限                                             |


7. Shell脚本与管道

| 命令/符号     | 功能描述                                                                 |
|---------------|--------------------------------------------------------------------------|
| >             | 输出重定向，覆盖写入文件                                                 |
| >>            | 输出重定向，追加写入文件                                                 |
| <             | 输入重定向，从文件读取输入                                               |
| |             | 管道，将前一个命令的输出作为下一个命令的输入                             |
| ;             | 顺序执行多个命令                                                         |
| &&            | 前一个命令成功时才执行下一个命令                                         |
| ||            | 前一个命令失败时才执行下一个命令                                         |
| `command`     | 命令替换，用命令的输出作为字符串                                         |
| $(command)    | 推荐的命令替换方式，功能同上                                             |
| xargs         | 将标准输入转换为命令行参数，常用于管道                                   |
| tee           | 从标准输入读取并写入文件，同时输出到标准输出                             |
| grep          | 文本搜索，支持正则匹配                                                   |
| awk           | 文本处理与格式化输出                                                     |
| sed           | 流编辑器，可对文本进行替换、删除、插入等操作                             |
| cut           | 按列提取文本内容                                                         |
| sort          | 对文本内容排序                                                           |
| uniq          | 去重或统计重复行                                                         |


## 面试高频考点

1. 进程和线程的区别

|特性|进程|线程|
|--|--|--|
|基本单位|资源分配的基本单位|调度和执行的基本单位|
|资源共享|不共享，各进程有独立的地址空间|共享|
|创建开销|大，需要独立分配资源|小，只需要创建寄存器和栈帧|
|切换速度|慢，涉及上下文切换和地址映射|快，只需要CPU切换上下文|
|通信方式|通过IPC（管道，共享内存，消息队列）|通过共享内存|
|多核利用|多进程并行|多线程并发|
|适用场景|独立任务|并发任务|

2. 进程和线程的通信方式

|通信方式|特点|适用场景|
|--|--|--|
|管道|单向、半双工、速度快|父子进程简单的数据传输|
|命令管道|双向，不同进程间，支持网络|无亲缘关系的进程间通信|
|消息队列|基于消息格式，支持多对多|多个无关联进程数据交换|
|共享内存|速度最快，需要同步机制|大量数据高速共享|
|套接字|支持本地和网络间进程间通信|网络通信、分布式系统|
|信号|轻量级，处理异步事件通知|通知进程执行特定操作|
|mmap|内存映射文件，共享文件内容|文件内容共享，进程间读写|

| 通信方式       | 简要说明                          | 典型场景                   |
|----------------|-----------------------------------|----------------------------|
| 共享内存变量   | 线程共享全局变量或堆内存          | 最常见方式，但需同步保护   |
| 互斥锁/读写锁  | 控制对共享资源的互斥或并发访问    | 临界区保护、多读单写       |
| 信号量         | 控制同时访问资源的线程数量        | 限制并发、生产者-消费者    |
| 条件变量       | 线程等待/通知机制                 | 生产者-消费者模型          |
| 自旋锁         | 忙等锁，适合临界区很短的场景      | 高性能短操作临界区         |
| 屏障（Barrier）| 多线程同步点                      | 并行计算阶段同步           |
| 消息队列/管道  | 在线程间传递消息或数据            | 异步通信、解耦             |
| 原子操作       | 硬件支持的原子级更新              | 简单计数器、标志位更新     |


3. 死锁的必要条件及其解决

1）**互斥条件**：资源一次只能被一个进程占用，如果其他进程需要使用该资源，必须等待其释放。
2）**请求与保持条件**：进程在等待其他资源时，不会释放已占有的资源，而是继续保持它们。
3）**不可剥夺条件**：资源不能被强制抢占，只能由占有资源的进程主动释放。
4）**循环等待条件**：存在一组进程 {P1, P2, ..., Pn}，其中每个进程都在等待下一个进程所持有的资源，形成一个环形等待链。

**银行家算法**避免死锁

4. 内核态与用户态

权限不同：
- 用户态（User Mode）：权限受限，不能直接访问硬件和关键资源。
- 内核态（Kernel Mode）：最高权限，可以访问所有硬件和内存。

运行范围：
- 用户态：执行应用程序代码。
- 内核态：执行操作系统内核代码（如系统调用、中断处理）。

切换开销：
- 用户态 ↔ 内核态需要上下文切换，保存和恢复寄存器、切换堆栈，开销较大。

5. 系统调用和库函数的区别

定义：

**系统调用**（System Call）：操作系统内核提供的接口，是用户程序访问内核资源（如文件、进程、网络）的唯一方式。

**库函数**（Library Function）：语言或运行库提供的函数，可能封装系统调用，也可能只是用户态逻辑。

执行环境：
- 系统调用会陷入内核态执行。
- 库函数通常在用户态执行，是否进入内核取决于实现。

例子：
read()：系统调用。
printf()：库函数，内部可能调用 write() 系统调用输出。

6. 操作系统的并发问题

**1. 用户态和内核态的区别**  
- **权限不同**：  
  - 用户态（User Mode）：权限受限，不能直接访问硬件和关键资源。  
  - 内核态（Kernel Mode）：最高权限，可以访问所有硬件和内存。  
- **运行范围**：  
  - 用户态：执行应用程序代码。  
  - 内核态：执行操作系统内核代码（如系统调用、中断处理）。  
- **切换开销**：  
  - 用户态 ↔ 内核态需要上下文切换，保存和恢复寄存器、切换堆栈，开销较大。  

---

**2. 系统调用和库函数的区别**  
- **定义**：  
  - 系统调用（System Call）：操作系统内核提供的接口，是用户程序访问内核资源的唯一方式。  
  - 库函数（Library Function）：语言或运行库提供的函数，可能封装系统调用，也可能只是用户态逻辑。  
- **执行环境**：  
  - 系统调用会陷入内核态执行。  
  - 库函数通常在用户态执行，是否进入内核取决于实现。  
- **例子**：  
  - `read()`：系统调用。  
  - `printf()`：库函数，内部可能调用 `write()` 系统调用输出。  

---

**3. 操作系统的并发控制是如何实现的**  
- **硬件层支持**：  
  - 原子指令（如 Test-and-Set、Compare-and-Swap）保证基本同步原语实现。  
- **内核同步机制**：  
  - 互斥锁（mutex）、自旋锁（spinlock）、读写锁（rwlock）。  
  - 信号量（semaphore）、条件变量（condition variable）。  
- **进程/线程调度**：  
  - 操作系统通过调度算法（如 CFS）在多个任务之间分配 CPU。  
- **高级抽象**：  
  - 管程（monitor）、消息队列、管道等，简化并发控制。  
- **目标**：  
  - 避免竞态条件（race condition）、死锁（deadlock）、保证互斥（mutual exclusion）和同步（synchronization）。  
